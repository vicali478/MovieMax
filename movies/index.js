/**
 * movies/index.js
 *
 * Comprehensive, self-contained client-side script for MovieMax movies/tvs page.
 * - Provides robust tab handling, type switching (movies/tvs), caching, pagination,
 *   trending display, genre/year grouping, carousels with infinite horizontal scroll,
 *   and graceful DOM fallback (creates essential elements if missing).
 *
 * Notes:
 * - This file is written to be defensive: it will create missing DOM containers so
 *   it does not throw if portions of the expected HTML are absent.
 * - All network calls use the Fetch API and validate responses.
 * - Includes utility functions, debounce/throttle helpers, and comprehensive error handling.
 *
 * Author: Generated by GitHub Copilot
 */


(function () {
  // -------------------------
  // Configuration & Defaults
  // -------------------------
  const DEFAULT_TYPE = 'movies'; // 'movies' or 'tvs'
  const DEFAULT_SELECTED_TAB = 'Trending';
  const GENERAL_TABS = ['Trending', 'Popular', 'Latest', 'A_Z', 'Year', 'Genre'];

  // Base image URL used by TMDB-like API responses
  const IMAGE_BASE_URL = 'https://films.wustream.com';

  // Throttle/debounce timings (ms)
  const RESIZE_DEBOUNCE_MS = 150;
  const SCROLL_THROTTLE_MS = 150;

  // DOM ids/classes that the script expects; will be created if not found
  const DOM_IDS = {
    tabsContainer: 'tabs',
    carouselSection: 'carouselSection',
    sectionContainer: 'section-container',
    pagination: 'pagination',
    loadingOverlay: 'loadingOverlay',
  };

  // -------------------------
  // State
  // -------------------------
  let generalData = Array.from(GENERAL_TABS);
  let selectedTab = DEFAULT_SELECTED_TAB;
  let type = DEFAULT_TYPE;

  // pages and totalPages keyed by tab names used for paginated title-based tabs
  let pages = {
    A_Z: 1,
    Popular: 1,
    Latest: 1,
    Trending: 1
  };

  let totalPages = {
    A_Z: 0,
    Popular: 0,
    Latest: 0,
    Trending: 0
  };

  // cache of movies grouped by tab and page: Map per tab -> Map(page->moviesArray)
  let titleMovies = {
    A_Z: new Map(),
    Popular: new Map(),
    Latest: new Map(),
    Trending: new Map()
  };

  // caches for grouped endpoints
  let trendingData = []; // items of various types: featured/movieList etc.
  let genreData = []; // array of { genre: 'Action', movies: [...] }
  let yearData = []; // array of { type: '2020', movies: [...] }

  // DOM references (initialized later)
  let tabsContainer;
  let carouselSection;
  let sectionContainer;
  let paginationEl;
  let loadingOverlay;

  // internal flags
  let isFetching = false;

  // -------------------------
  // Utilities
  // -------------------------

  function safeGetById(id) {
    const el = document.getElementById(id);
    if (el) return el;
    // create minimal fallback element if missing
    const fallback = document.createElement('div');
    fallback.id = id;
    // append to body so styles that rely on existing structure won't break entirely
    document.body.appendChild(fallback);
    return fallback;
  }

  function createElement(tag, options = {}) {
    const el = document.createElement(tag);
    if (options.id) el.id = options.id;
    if (options.className) el.className = options.className;
    if (options.textContent) el.textContent = options.textContent;
    if (options.innerHTML) el.innerHTML = options.innerHTML;
    
    if (options.attrs) {
      for (const [k, v] of Object.entries(options.attrs)) {
        el.setAttribute(k, v);
      }
    }
    return el;
  }

  function clamp(value, min, max) {
    return Math.min(Math.max(value, min), max);
  }

  function isObject(obj) {
    return obj !== null && typeof obj === 'object' && !Array.isArray(obj);
  }

  // Small safe JSON parse function
  async function fetchJson(url, options = {}) {


    const headers = {
      ...(options.headers || {}),
    };

    const res = await fetch(url, { ...options, headers });
    if (!res.ok) {
      const text = await res.text().catch(() => '');
      const err = new Error(`Network error: ${res.status} ${res.statusText}`);
      err.status = res.status;
      err.responseText = text;
      throw err;
    }
    const parsed = await res.json();
    return parsed;
  }

  // Debounce: returns a wrapper that delays execution until wait ms after last call
  function debounce(fn, wait = 100) {
    let t = null;
    return function (...args) {
      if (t) clearTimeout(t);
      t = setTimeout(() => {
        t = null;
        fn.apply(this, args);
      }, wait);
    };
  }

  // Throttle: ensures fn is called at most once every limit ms
  function throttle(fn, limit = 100) {
    let inThrottle = false;
    let lastArgs = null;
    return function (...args) {
      if (!inThrottle) {
        fn.apply(this, args);
        inThrottle = true;
        setTimeout(() => {
          inThrottle = false;
          if (lastArgs) {
            fn.apply(this, lastArgs);
            lastArgs = null;
          }
        }, limit);
      } else {
        lastArgs = args;
      }
    };
  }

  // Create a safe image URL: if poster starts with http return it else prefix with IMAGE_BASE_URL
  function buildImageUrl(posterPath = '') {
    if (!posterPath) return '';
    return posterPath.startsWith('http') ? posterPath : `${IMAGE_BASE_URL}${posterPath}`;
  }

  // Safely set innerText or textContent
  function setText(el, text) {
    if (!el) return;
    el.textContent = typeof text === 'string' ? text : String(text ?? '');
  }

  // -------------------------
  // DOM Creation Helpers
  // -------------------------

  function ensureDomStructure() {
    tabsContainer = safeGetById(DOM_IDS.tabsContainer);
    carouselSection = safeGetById(DOM_IDS.carouselSection);
    sectionContainer = safeGetById(DOM_IDS.sectionContainer);
    paginationEl = safeGetById(DOM_IDS.pagination);
    loadingOverlay = safeGetById(DOM_IDS.loadingOverlay);

    // Basic classes and styles to ensure elements are displayed in an expected layout.
    // We keep this minimal: real application CSS should override if present.
    tabsContainer.classList.add('movie-tabs-container');
    carouselSection.classList.add('movie-carousel-section');
    sectionContainer.classList.add('movie-section-container');
    paginationEl.classList.add('movie-pagination');
    loadingOverlay.classList.add('movie-loading-overlay');

    // Ensure tabs exist - create list items for each generalData entry if not already present
    if (!tabsContainer.querySelectorAll('.tab-item').length) {
      for (const value of generalData) {
        const tab = createElement('li', { className: 'tab-item', textContent: value.trim() });
        tabsContainer.appendChild(tab);
      }
    }

    // ensure nav links for type switching exist (movies/tvs)
    // The app originally expects .nav-link elements. If none exist, provide simple toggles.
    if (!document.querySelectorAll('.nav-link').length) {
      const navWrapper = createElement('div', { className: 'movie-type-nav' });
      const moviesLink = createElement('button', { className: 'nav-link', textContent: 'movies' });
      moviesLink.setAttribute('data-type', 'movies');
      const tvsLink = createElement('button', { className: 'nav-link', textContent: 'tvs' });
      tvsLink.setAttribute('data-type', 'tvs');
      navWrapper.appendChild(moviesLink);
      navWrapper.appendChild(tvsLink);
      // Insert navigation above tabs or at start of body
      document.body.insertBefore(navWrapper, tabsContainer);
    }

    // ensure loading overlay content minimal
    if (!loadingOverlay.innerHTML.trim()) {
      loadingOverlay.innerHTML = '<div class="loader">Loading...</div>';
    }
  }

  // -------------------------
  // Type switching & Tabs
  // -------------------------

  function updateActiveTypeLinks() {
    document.querySelectorAll('.nav-link').forEach(link => {
      const linkType = link.getAttribute('data-type');
      if (linkType === type) {
        link.classList.add('active');
      } else {
        link.classList.remove('active');
      }
    });
  }

  function setupTypeSwitching() {
    document.querySelectorAll('.nav-link').forEach(link => {
      link.removeEventListener('click', onTypeLinkClick);
      link.addEventListener('click', onTypeLinkClick);
    });
  }

  function onTypeLinkClick(e) {
    const element = e.currentTarget;
    switchType(element);
  }

  // Function to switch type between movies and tvs and reset all variables and refetch data
  function switchType(element) {
    if (!element) return;
    const newType = element.getAttribute('data-type');
    if (!newType || newType === type) return;

    document.querySelectorAll('.nav-link').forEach(link => {
      link.classList.remove('active');
    });

    // Add 'active' to matching links
    document.querySelectorAll(`[data-type="${newType}"]`).forEach(link => {
      link.classList.add('active');
    });

    type = newType;
    resetFilters();
    // Reset UI state: show trending by default on type change
    selectedTab = 'Trending';
    setActiveTabUI(selectedTab);
    displayTrending().catch(err => {
      console.error('Error while fetching trending after type switch:', err);
    });
  }

  // reset all variables and data
  function resetFilters() {
    pages = {
      A_Z: 1,
      Popular: 1,
      Latest: 1,
      Trending: 1
    };
    totalPages = {
      A_Z: 0,
      Popular: 0,
      Latest: 0,
      Trending: 0
    };

    titleMovies = {
      A_Z: new Map(),
      Popular: new Map(),
      Latest: new Map(),
      Trending: new Map()
    };

    trendingData = [];
    genreData = [];
    yearData = [];
  }

  function setActiveTabUI(tabName) {
    document.querySelectorAll('#' + DOM_IDS.tabsContainer + ' .tab-item').forEach(el => {
      if (el.textContent.trim() === tabName) {
        el.classList.add('active');
      } else {
        el.classList.remove('active');
      }
    });
  }

  function setupTabs() {
    const tabs = Array.from(document.querySelectorAll('#' + DOM_IDS.tabsContainer + ' .tab-item'));
    if (tabs.length === 0) return;
    tabs.forEach(tab => {
      tab.removeEventListener('click', onTabClick);
      tab.addEventListener('click', onTabClick);
    });
  }

  function onTabClick(e) {
    const tab = e.currentTarget;
    if (!tab) return;
    const value = tab.textContent.trim();
    selectedTab = value;
    document.querySelector('.tab-item.active')?.classList.remove('active');
    tab.classList.add('active');

    switch (selectedTab) {
      case 'Trending':
        displayTrending().catch(err => console.error('displayTrending', err));
        break;
      case 'Latest':
      case 'Popular':
      case 'A_Z':
        toTitle().catch(err => console.error('toTitle', err));
        break;
      case 'Year':
        filterByYear().catch(err => console.error('filterByYear', err));
        break;
      case 'Genre':
        filterByGenre().catch(err => console.error('filterByGenre', err));
        break;
      default:
        console.warn('Unknown Tab:', selectedTab);
    }
  }

  // -------------------------
  // Loading Indicator
  // -------------------------
  function toggleLoading(show) {
    if (!loadingOverlay) return;
    if (show) {
      loadingOverlay.classList.add('active');
      // make overlay visible
      loadingOverlay.style.display = 'flex';
    } else {
      loadingOverlay.classList.remove('active');
      loadingOverlay.style.display = 'none';
    }
  }

  // -------------------------
  // Fetching data
  // -------------------------
  async function fetchMovies() {
    // pages[selectedTab] must exist
    const pageIndex = pages[selectedTab] || 1;
    const urlSafeTab = selectedTab.toString().toLowerCase();
    let responseData;
    try {
      isFetching = true;
      const url = `/api/${encodeURIComponent(type)}/${encodeURIComponent(urlSafeTab)}/${encodeURIComponent(pageIndex)}`;
      const allMovies = await fetchJson(url);
      // Expected shape: { totalPages, page, movies | tvs } where key may be type
      // Normalize: find array under key either 'movies' or type
      const keyCandidates = ['movies', 'tvs', 'movies', type];
      let moviesArray = null;
      for (const k of keyCandidates) {
        if (k && Array.isArray(allMovies[k])) {
          moviesArray = allMovies[k];
          break;
        }
      }
      // Fallback: if response has property equal to type (movies/tvs) use it
      if (!moviesArray && Array.isArray(allMovies[type])) {
        moviesArray = allMovies[type];
      }
      // If still not found, try the first array value in response
      if (!moviesArray) {
        for (const v of Object.values(allMovies)) {
          if (Array.isArray(v)) {
            moviesArray = v;
            break;
          }
        }
      }

      totalPages[selectedTab] = Number(allMovies['totalPages'] || allMovies['total_pages'] || 0);
      window.scrollTo({ top: 0, behavior: 'smooth' });

      responseData = {
        movies: moviesArray || [],
        page: Number(allMovies['page'] || allMovies['p'] || pageIndex)
      };
    } catch (error) {
      console.error('Error loading categories:', error);
      responseData = { movies: [], page: pageIndex };
    } finally {
      isFetching = false;
    }
    return responseData;
  }

  async function fetchTrending() {
    try {
      const url = `/api/${encodeURIComponent(type)}/categories`;
      const data = await fetchJson(url);
      // expected to return an array or object with 'data' property
      return Array.isArray(data) ? data : (Array.isArray(data.data) ? data.data : []);
    } catch (error) {
      console.error('Error loading trending data:', error);
      return [];
    }
  }


  async function fetchCategories() {
    try {
      const url = `/api/${encodeURIComponent(type)}/grouped-by-genre`;
      const data = await fetchJson(url);
      return Array.isArray(data.data) ? data.data : [];
    } catch (error) {
      console.error('Error loading categories:', error);
      return [];
    }
  }

  async function fetchByYear() {
    try {
      const url = `/api/${encodeURIComponent(type)}/grouped-by-year`;
      const data = await fetchJson(url);
      return Array.isArray(data.data) ? data.data : [];
    } catch (error) {
      console.error('Error loading by-year data:', error);
      return [];
    }
  }

  // -------------------------
  // Rendering helpers
  // -------------------------

  function createLoader() {
    const wrapper = createElement('div', { className: 'loader-wrapper' });
    const progressIndicator = createElement('span', { className: 'loading' });
    const loadingInner = createElement('span', { className: 'loading-indicator' });
    progressIndicator.appendChild(loadingInner);
    wrapper.appendChild(progressIndicator);
    return wrapper;
  }

  function createItem(movie) {
    const item = createElement('div', { className: 'item' });
    item.addEventListener('click', () => {
      goToDetails(movie);
    });
    const posterPath = movie.posterUrl || movie.poster_path || movie.poster || '';
    const imageUrl = buildImageUrl(posterPath);
    const img = createElement('img', { attrs: { src: imageUrl || '', alt: movie.title || '' } });
    const title = createElement('h3', { textContent: movie.title || movie.name || 'Untitled' });
    item.appendChild(img);
    item.appendChild(title);
    return item;
  }

  function createMovieCard(movie) {
    const movieCard = createElement('div', { className: 'movie-card' });
    movieCard.addEventListener('click', () => {
      goToDetails(movie);
    });
    const posterPath = movie.posterUrl || movie.poster_path || movie.poster || '';
    const imgUrl = buildImageUrl(posterPath);
    const img = createElement('img', { attrs: { src: imgUrl || '', alt: movie.title || movie.name || '' } });
    const h = createElement('h3', { textContent: movie.title || movie.name || 'Untitled' });
    movieCard.appendChild(img);
    movieCard.appendChild(h);
    return movieCard;
  }

  function createTrendItem(movie) {
    const movieItem = createElement('div', { className: 'movie-list-item' });

    const movieImg = createElement('img', { className: 'movie-list-item-img' });
    const imgPath = movie.backdropUrl ?? movie.backdrop_path ?? movie.posterUrl ?? movie.poster_path ?? '';
    movieImg.src = buildImageUrl(imgPath);

    const movieTitle = createElement('span', { className: 'movie-list-item-title', textContent: movie.title || movie.name || '' });

    const movieDesc = createElement('p', { className: 'movie-list-item-desc', textContent: movie.overview || movie.description || '' });

    const movieButton = createElement('button', { className: 'movie-list-item-button', textContent: 'VIEW' });

    movieButton.addEventListener('click', (e) => {
      e.stopPropagation();
      goToDetails(movie);
    });

    movieItem.addEventListener('click', () => {
      goToDetails(movie);
    });

    movieItem.appendChild(movieImg);
    movieItem.appendChild(movieTitle);
    movieItem.appendChild(movieDesc);
    movieItem.appendChild(movieButton);
    return movieItem;
  }

  // -------------------------
  // Pagination rendering
  // -------------------------

  function renderPagination() {
    if (!paginationEl) return;
    paginationEl.innerHTML = ''; // Clear existing pagination

    const total = Math.max(1, Number(totalPages[selectedTab] || 1));
    const current = clamp(Number(pages[selectedTab] || 1), 1, total);

    const isMobile = window.innerWidth <= 768;

    // Previous button
    const prevButton = createElement('button', { textContent: 'Prev' });
    prevButton.disabled = current === 1;
    prevButton.addEventListener('click', () => {
      pages[selectedTab] = current === 1 ? total : current - 1;
      toTitle().catch(err => console.error('toTitle on prev', err));
    });
    paginationEl.appendChild(prevButton);

    // Dynamic page numbers
    if (isMobile) {
      const maxPagesToShow = 5;
      let startPage = Math.max(1, current - Math.floor(maxPagesToShow / 2));
      let endPage = Math.min(total, startPage + maxPagesToShow - 1);

      if (endPage - startPage < maxPagesToShow - 1) {
        startPage = Math.max(1, endPage - maxPagesToShow + 1);
      }

      for (let i = startPage; i <= endPage; i++) {
        const pageButton = createElement('button', { textContent: String(i) });
        if (i === current) pageButton.classList.add('active');
        pageButton.addEventListener('click', () => {
          pages[selectedTab] = i;
          toTitle().catch(err => console.error('toTitle on page click', err));
        });
        paginationEl.appendChild(pageButton);
      }
    } else {
      const maxPagesToShow = 10;
      let startPage = Math.max(1, current - Math.floor(maxPagesToShow / 2));
      let endPage = Math.min(total, startPage + maxPagesToShow - 1);

      if (endPage - startPage < maxPagesToShow - 1) {
        startPage = Math.max(1, endPage - maxPagesToShow + 1);
      }

      for (let i = startPage; i <= endPage; i++) {
        const pageButton = createElement('button', { textContent: String(i) });
        if (i === current) pageButton.classList.add('active');
        pageButton.addEventListener('click', () => {
          pages[selectedTab] = i;
          toTitle().catch(err => console.error('toTitle on page click', err));
        });
        paginationEl.appendChild(pageButton);
      }
    }

    // Last Page button (if on last page, show first page instead)
    const lastPageButton = createElement('button', { textContent: String(current === total ? 1 : total) });
    lastPageButton.addEventListener('click', () => {
      pages[selectedTab] = current === total ? 1 : total;
      toTitle().catch(err => console.error('toTitle on last', err));
    });
    paginationEl.appendChild(lastPageButton);

    // Next button
    const nextButton = createElement('button', { textContent: 'Next' });
    nextButton.disabled = current === total;
    nextButton.addEventListener('click', () => {
      pages[selectedTab] = current === total ? 1 : current + 1;
      toTitle().catch(err => console.error('toTitle on next', err));
    });
    paginationEl.appendChild(nextButton);
  }

  // -------------------------
  // Page rendering flows
  // -------------------------

  function updatePage(movies) {
    // movies is expected to be an array
    filterByName(movies);
    renderPagination();
  }

  function filterByName(movies) {
    if (!sectionContainer) return;
    // Hide carousel (title-based pages show grid)
    if (carouselSection) carouselSection.style.display = 'none';

    const moviesGrid = createElement('div', { className: 'movies-grid' });

    (movies || []).forEach(movieData => {
      const movieCard = createItem(movieData);
      moviesGrid.appendChild(movieCard);
    });

    sectionContainer.innerHTML = "";
    sectionContainer.style.display = 'block';
    sectionContainer.appendChild(moviesGrid);
    toggleLoading(false);
  }

  async function toTitle() {
    toggleLoading(true);

    const tabKey = selectedTab;
    if (!titleMovies[tabKey]) {
      titleMovies[tabKey] = new Map();
    }

    const pageIndex = pages[tabKey] || 1;

    if (!titleMovies[tabKey].has(pageIndex)) {
      const data = await fetchMovies();
      titleMovies[tabKey].set(data.page, data.movies);
    }

    const pageMovies = titleMovies[tabKey].get(pageIndex) || [];

    updatePage(pageMovies);

    // re-register resize handler for pagination rendering
    const debouncedRender = debounce(renderPagination, RESIZE_DEBOUNCE_MS);
    window.removeEventListener('resize', debouncedRender);
    window.addEventListener('resize', debouncedRender);
  }

  // -------------------------
  // Filters: Genre & Year
  // -------------------------

  async function filterByGenre() {
    toggleLoading(true);
    if (!Array.isArray(genreData) || genreData.length === 0) {
      genreData = await fetchCategories();
    }
    carouselSection.innerHTML = "";
    for (let idx = 0; idx < genreData.length; idx++) {
      const data = genreData[idx];
      carouselSection.appendChild(createCarousel(data, 'genre'));
    }
    toggleLoading(false);
    // On genre/year views we don't use the pagination component
    if (paginationEl) paginationEl.innerHTML = "";
    // Ensure section container is hidden
    if (sectionContainer) sectionContainer.style.display = 'none';
  }

  async function filterByYear() {
    toggleLoading(true);
    if (!Array.isArray(yearData) || yearData.length === 0) {
      yearData = await fetchByYear();
    }
    carouselSection.innerHTML = "";
    for (let idx = 0; idx < yearData.length; idx++) {
      const data = yearData[idx];
      carouselSection.appendChild(createCarousel(data, 'year'));
    }
    toggleLoading(false);
    if (paginationEl) paginationEl.innerHTML = "";
    if (sectionContainer) sectionContainer.style.display = 'none';
  }

  // -------------------------
  // Carousel creation & infinite scroll horizontally
  // -------------------------

  function createCarousel(data, kind) {
    if (!carouselSection) carouselSection = safeGetById(DOM_IDS.carouselSection);
    carouselSection.style.display = 'flex';
    if (sectionContainer) sectionContainer.style.display = 'none';

    const carousel = createElement('div', { className: 'carousel' });

    // title
    const title = createElement('h3', { textContent: data[kind] || data.genre || data.type || 'Untitled' });
    carousel.appendChild(title);

    const itemsContainer = createElement('div', { className: 'carousel-items' });
    itemsContainer.dataset.page = '1';
    itemsContainer.dataset.loading = 'false';

    // if provided movies are in an array property key name 'movies' or the key equal to kind
    const moviesArray = Array.isArray(data[type]) ? data[type] : (Array.isArray(data[kind]) ? data[kind] : []);
    for (let i = 0; i < moviesArray.length; i++) {
      itemsContainer.appendChild(createItem(moviesArray[i]));
    }

    const loader = createLoader();

    // attach scroll handler with throttle
    const handler = throttle(async () => {
      if (itemsContainer.dataset.loading === 'true') return;
      const { scrollLeft, scrollWidth, clientWidth } = itemsContainer;
      if (scrollLeft + clientWidth >= scrollWidth - 2) {
        // reached end, load next page
        itemsContainer.appendChild(loader);
        itemsContainer.dataset.loading = 'true';
        const currentPage = parseInt(itemsContainer.dataset.page || '1', 10);

        try {
          if (kind === 'genre') {
            // endpoint: /api/{type}/genre/{page}?genre={genreName}
            const genreParam = encodeURIComponent(data.genre || (data[kind] || ''));
            const response = await fetchJson(`/api/${encodeURIComponent(type)}/genre/${encodeURIComponent(currentPage + 1)}?genre=${genreParam}`);
            const movies = Array.isArray(response[type]) ? response[type] : (Array.isArray(response.movies) ? response.movies : []);
            // append to cache if possible
            const genreItem = genreData.find(g => (g.genre || '') === (data.genre || ''));
            if (genreItem && Array.isArray(genreItem.movies)) {
              genreItem.movies.push(...movies);
            }
            movies.forEach(m => itemsContainer.insertBefore(createItem(m), loader));
          } else if (kind === 'trending') {

            const response = await fetchJson(`/api/${encodeURIComponent(type)}/categories/${encodeURIComponent(data.category)}/${encodeURIComponent(currentPage + 1)}`);
            const movies = Array.isArray(response[type]) ? response[type] : (Array.isArray(response.movies) ? response.movies : []);
            // append to cache if possible
            const genreItem = genreData.find(g => (g.genre || '') === (data.genre || ''));
            if (genreItem && Array.isArray(genreItem.movies)) {
              genreItem.movies.push(...movies);
            }
            movies.forEach(m => itemsContainer.insertBefore(createItem(m), loader));
          } else {
            // year-based or generic: /api/{type}/{type}/{data[type]}/{page}
            const slug = encodeURIComponent(String(data[kind] || data.type || data.year || data[kind + '_name'] || ''));
            const response = await fetchJson(`/api/${encodeURIComponent(type)}/year/${slug}/${encodeURIComponent(currentPage + 1)}`);
            const movies = Array.isArray(response[type]) ? response[type] : (Array.isArray(response.movies) ? response.movies : []);
            const yearItem = yearData.find(y => (y.type || '') === (data[kind] || ''));
            if (yearItem && Array.isArray(yearItem.movies)) {
              yearItem.movies.push(...movies);
            }
            movies.forEach(m => itemsContainer.insertBefore(createItem(m), loader));
          }

          itemsContainer.dataset.page = (currentPage + 1).toString();
        } catch (err) {
          console.error('Error while loading more carousel items:', err);
        } finally {
          itemsContainer.dataset.loading = 'false';
          if (itemsContainer.contains(loader)) {
            itemsContainer.removeChild(loader);
          }
        }
      }
    }, SCROLL_THROTTLE_MS);

    itemsContainer.addEventListener('scroll', handler);

    carousel.appendChild(itemsContainer);
    return carousel;
  }

  function formatedDate(dateString) {
  const date = new Date(dateString);

  if (isNaN(date)) return ""; // handle invalid dates safely

  const day = date.getDate();
  const month = date.toLocaleString('en-US', { month: 'short' }); 
  const year = date.getFullYear();

  return `${day} ${month} ${year}`;
}

  // -------------------------
  // Trending display
  // -------------------------

  async function displayTrending() {
    toggleLoading(true);
    if (!Array.isArray(trendingData) || trendingData.length === 0) {
      trendingData = await fetchTrending();
    }

    // create container
    const container = createElement('div', { className: 'container' });

    trendingData.forEach(item => {
      if (!item || !item.type) return;

      switch (item.type) {
        case 'featured': {
          const featured = createElement('div', { className: 'featured-content' });

          const imgPath = item.data?.backdropUrl ?? item.data?.backdrop_path ?? item.data?.posterUrl ?? item.data?.poster_path ?? '';
          const fullImg = buildImageUrl(imgPath);
          featured.style.background = [
            'linear-gradient(to top, rgba(0, 0, 0, 1) 0%, rgba(0, 0, 0, 0.92) 30%, rgba(0, 0, 0, 0) 100%)',
            `url('${fullImg}')`
          ].join(', ');

          featured.style.backgroundRepeat = 'no-repeat';
          featured.style.backgroundSize = 'cover';
          featured.style.backgroundPosition = 'center';

          const featuredTitle = createElement('h4', { className: 'featured-title', textContent: item.data?.title || item.data?.name || '' });

          // â­ Rating Row
          const ratingRow = createElement('div', { className: 'rating-row' });

          // star + vote average
          ratingRow.appendChild(createElement('span', {
            className: 'rating-item',
            innerHTML: `â­ ${item.data?.voteAverage?.toFixed(1) ?? '0.0'}`
          }));

          // release date
          if (item.data?.releaseDate) {
            ratingRow.appendChild(createElement('span', {
              className: 'rating-item',
              innerHTML: `ðŸ“… ${formatedDate(item.data?.releaseDate)}`
            }));
          }
          // vote count
          ratingRow.appendChild(createElement('span', {
            className: 'rating-item',
            innerHTML: `ðŸ—³ï¸ ${item.data?.voteCount ?? 0}`
          }));

          // mpa rating
          if (item.data?.mpaRating) {
            ratingRow.appendChild(createElement('span', {
              className: 'rating-item',
              innerHTML: `ðŸŽžï¸ ${item.data.mpaRating}`
            }));
          }

          const featuredDesc = createElement('p', { className: 'featured-desc', textContent: item.data?.overview || item.data?.synopsis || '' });
          const featuredButton = createElement('button', { className: 'featured-button', textContent: item.buttonText || 'VIEW' });


          featuredButton.addEventListener('click', () => {
            goToDetails(item.data);
          });

          featured.appendChild(featuredTitle);
          featured.appendChild(ratingRow);

          featured.appendChild(featuredDesc);
          featured.appendChild(featuredButton);

          container.appendChild(featured);
          break;
        }

        case 'movieList': {

          let data = {};

          data.type = item.title;
          data[type] = item[type];
          data.category = item.category;
          container.appendChild(createCarousel(data, 'trending'));
          break;
        }

        default:
          console.warn('Unknown trending item type:', item.type);
      }
    });

    if (carouselSection) carouselSection.style.display = 'none';
    if (paginationEl) paginationEl.innerHTML = '';
    if (sectionContainer) {
      sectionContainer.innerHTML = '';
      sectionContainer.appendChild(container);
      sectionContainer.style.display = 'block';
    }

    toggleLoading(false);
  }

  // -------------------------
  // Navigation helpers
  // -------------------------

  function goToDetails(data) {
    if (!data) return;
    // When possible prefer to use type information on the object, otherwise fallback to current global type
    const contentType = data.type || type;
    const id = data.id;
    if (!id) {
      // fallback: no id available
      console.warn('goToDetails called without an id, data:', data);
      return;
    }
    window.location.href = `/${contentType}/${encodeURIComponent(id)}`;
  }

  function goToSearch() {
    window.location.href = '/search';
  }

  // -------------------------
  // Scroll handlers to hide/show tabs
  // -------------------------
  let lastScrollTop = 0;
  function onWindowScroll() {
    const current = window.pageYOffset || document.documentElement.scrollTop;
    const tabsEl = document.getElementById(DOM_IDS.tabsContainer);
    if (!tabsEl) return;
    if (current > lastScrollTop) {
      // scrolling down
      tabsEl.style.display = 'none';
    } else {
      // scrolling up
      tabsEl.style.display = 'flex';
    }
    lastScrollTop = current <= 0 ? 0 : current;
  }

  // -------------------------
  // Initialization
  // -------------------------

  async function init() {
    try {
      ensureDomStructure();
      // Setup event listeners
      setupTypeSwitching();
      setupTabs();

      // Apply initial active states
      updateActiveTypeLinks();
      setActiveTabUI(selectedTab);

      // Scroll listener for hiding tabs (debounced)
      window.removeEventListener('scroll', onWindowScroll);
      window.addEventListener('scroll', debounce(onWindowScroll, 100), { passive: true });

      // Default display: Trending
      toggleLoading(true);
      await displayTrending();
    } catch (err) {
      console.error('Initialization error:', err);
      toggleLoading(false);
    }
  }

  // Attach DOMContentLoaded
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', (e) => {
      // Prevent default isn't needed here; original code had e.preventDefault which is not applicable on DOMContentLoaded.
      init().catch(err => console.error('init error', err));
    });
  } else {
    // already loaded
    init().catch(err => console.error('init error', err));
  }

  // -------------------------
  // Public API (exposed on window for debugging)
  // -------------------------
  window.MovieMax = window.MovieMax || {};
  Object.assign(window.MovieMax, {
    switchType,
    fetchMovies,
    fetchTrending,
    fetchCategories,
    fetchByYear,
    displayTrending,
    filterByGenre,
    filterByYear,
    toTitle,
    goToDetails,
    resetFilters,
    getState: () => ({
      type,
      selectedTab,
      pages: JSON.parse(JSON.stringify(pages)),
      totalPages: JSON.parse(JSON.stringify(totalPages))
    })
  });

  // -------------------------
  // End of file
  // -------------------------
})();